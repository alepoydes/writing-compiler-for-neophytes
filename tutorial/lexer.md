# Теория компиляторов для неофитов

## Лексический анализатор

[Устройство компилятора <](phases.md)
[Содержание](content.md)
[> Синтаксический анализатор](parser.md)

[Лабораторная работа №3 "Лексер"](../lesson03/README.md)

-------

В этой лекции мы начнем изучать, как компилятор понимает, что написано в программе.
Занимающаяся разбором исходного кода часть компилятора называется синтаксическим анализатором.
Фундаментальная основа для работы синтакcического анализа заложена в
[теории формальных языков](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA).
В рамках этой теории язык задается с помощью
[формальной грамматики](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0),
которая позволяет получить все синтаксически верные исходные коды программ на рассматриваемом языке,
и задает способ группировки слов языка в понятия.

Чтобы задать формальные язык, нужно сначала задать алфавит, т.е. множество
всех символов, которые могут присутствовать в словах языка.
В настоящее время в качестве множества символов предпочтительно использовать
[юникод](https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4),
так как это значительно упрощает использование в программе разнообразных
естественных языков.
Формальных язык задается множеством всех слов, входящих в язык, причем
под словом в данном случае подразумевается программа целиком.
Количество слов в нетривиальном языке бесконечно, поэтому вместо перечисления
всех слов используются конечный набор правил, по которым можно построить весь язык.
В практическом плане удобно использовать правила максимально простого вида,
вместо описания, например, на русском языке или на Java.
Формальная грамматика задается правилами вида:

```
что заменить ::= на что заменить
```

Строки `что заменить` и `на что заменить` состоят из букв алфавита,
называемых *терминалами*, и из набора не входящих в алфавит символов,
называемых *нетерминалами*.
Среди нетерминалов выделяют особый, называемый *стартовым символом*.
Вывод слов языка всегда начинается со строки, состоящей
только из стартового символа.
К этой строке начинают применяться правила формальной грамматике,
причем каждое применение сводится замене подстроки, совпадающей
с левой часть правила (`что заменить`) на строку из правой части
правила (`на что заменить`).
Важно отметить, что правила применяются в произвольном порядке и
в любом количестве.
Как только в результате применения правил грамматики
получается строка целиком состоящая из терминалов,
эта строка объявляется входящей в язык,
причем все слова языка должны получаться таким образом.

Существует несколько уровней иерархии языков
(см. [иерархия Хомского](https://ru.wikipedia.org/wiki/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F_%D0%A5%D0%BE%D0%BC%D1%81%D0%BA%D0%BE%D0%B3%D0%BE))
по сложности из разбора.
Для задания программ на языках программирования почти всегда достаточно
контекстно-свободных грамматик,
т.е. грамматик, в левой части правил которых стоит один символ
и он нетерминал.
Символ в левой части часто выражает какое-то понятие,
в этом случае правила объясняют, как понятие раскрывается через другие символы.
Например, рассмотрим грамматику (воспользуемся для записи грамматики
[формой Бэкуса-Наура](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0)
) для десятичной записи целого числа:

```
<число> ::= <знак> <цифры>
<знак> ::= + | - |
<цифры> ::= <цифра> | <цифра> <цифры>
<цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

В БНФ записи нетерминалы записываются в угловых скобках,
символ `|` используется для перечисления вариантов замены левой части,
и мы записываем правила для стартового символа первыми.
Прочитать эту грамматику можно следующим образом:
чтобы получить число нужно сначала написать знак, затем записать цифры.
Знаком могут быть символы `+` и `-` или пустая строка.
Цифры - это строка либо из одной цифры, либо из цифры, за которой идут другие цифры.
Подробнее контекстно-свободные грамматики мы рассмотрим следующем уроке.
Пока заметим, что правила для `<цифры>` имеют еще более специальный вид,
чем диктуется контекстно-свободной грамматикой.
Если все правила грамматики имеют один из двух видов:

```
нетерминал ::= терминал
нетерминал ::= терминал нетерминал
```

то такая грамматика называется регулярной.
Регулярные грамматики существенно проще контекстно-свободных,
поэтому мы начнем изучение грамматик с регулярных.
Регулярные грамматики используются достаточно широко,
нас же будет интересовать конкретная задача: написание лексического анализатора.

Что делает лексический анализатор, и зачем нужен он нужен?
Лексический анализатор выделяет в исходном коде программы *лексемы*,
т.е. подстроки, которые с точки зрения последующего синтаксического анализа
будут рассматриваться как один символ.
Например, с точки зрения программы на C все числовые [литералы]
(https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
ведут себя одним образом, не важно, какое конкретно числовое значение он имеет,
поэтому числовое значение литерала восстанавливается на этапе лексического
анализа, а последующий синтаксический анализ работает с числом, как с одним целым.
Т.о. лексический анализатор преобразует цепочку символов алфавита программы (юникод)
в цепочку лексем, где отдельные лексемы могут быть числом, идентификатором,
оператором, комментарием и т.п.
Как правило лексический анализатор выполняет разбор регулярного языка,
а синтаксический анализатор - контекстно-свободного.
Так как регулярная грамматика является также контекстно-свободной,
то этап лексического анализа можно было бы опустить,
однако использование лексического анализатора позволяет добиться двух вещей:

1. Регулярная грамматика разбирается быстрее контекстно-свободной,
т.е. использование лексера ускоряет работу компилятора.
1. Сбор лексером нескольких символов в один позволяет уменьшить число
символов для предпросмотра для синтаксического анализатора, что позволяет
использовать меньше памяти или более простые анализаторы.

Для задания лексера необходимо указать перечень регулярных выражений
и лексемы, которые будут выдаваться лексером, если регулярное выражение
находится в исходном коде программы.
Регулярное выражение является одним из способов задания регулярной грамматики.
Регулярное выражение (часто сокращается до *regexp*) представляет собой
последовательность символов, операторов `+`, `*` и `?`, скобок `(`, `)`
и регулярных выражений.
С помощью формальной грамматики регулярное выражение можно определить следующим образом:

```
<regexp> ::= <term> <regexp> ; список элементов <term>
<regexp> ::= <regexp> <or> <regexp> ; варианты или
<or> ::= <символ вертикальной черты>
<term> ::=  ; пустая строка
<term> ::= <literal> ; символ из алфавита исходного языка, обозначает буквально себя
<term> ::= ( <regexp> ) ; группа символов, операторы применяются ко всей группе
<term> ::= <term> <operator> ; оператор, примененный к некоторой группе
<operator> ::= + | * | ?
```

Скобки в регулярных выражениях служат только для выделения части выражения,
к которой применяется оператор.
В качестве операторов используются:

* `+` - повтор предшествующего оператору символа или группы один и более раз;
* `*` - повтор ноль и более раз;
* `?` - предшествующее выражение может встречаться один раз или отсутствовать.

В качестве примера рассмотрим выражение `(+|-)?(0|1|2|3|4|5|6|7|8|9)+`,
которому соответствуют десятичные представления целых чисел со знаком,
контекстно-свободную грамматику для которых мы рассмотрели выше.

Почему регулярная грамматика считается особенно простой?
Как построить регулярную грамматику, соответствующую регулярному выражению?
Как проверить, удовлетворяет ли строка регулярному выражению?
Попробуем ответить на эти вопросы.

Регулярная грамматика считается особенно простой,
так как каждой регулярной грамматике однозначно соответствует
конечный автомат, который позволяет максимально быстро генерировать
слова и проверять принадлежность слова языку.

*Конечным автоматом* называют устройство, имеющее конечное число состояний,
между которыми оно может делать переходы.
Автомат задается своими состояниями и множеством разрешенных переходов.
Первоначально автомат находится в стартовом состоянии, которое мы будем
обозначать `0`.
Часть состояний помечаются как *остановочные состояния*,
попадая в эти состояния автомат имеет право завершить работу.
Автомат для порождения языка при переходе может добавлять
в конец слова одну букву.
В начале работы автомата генерируемое слово не содержит ни одной буквы,
при последующей работе автомата к слову приписываются буквы,
создание слова прекратится в одном из остановочных состояний.
Переходы без приписывания буквы будем называть эпсилон переходами.

Покажем, как построить конечный автомат, соответствующий регулярной грамматике.
Заметим, что частично выведенная строка для регулярной грамматики
вседа содержит только один нетерминал, расположенный в конце строки.
В начале вывода строка состоит из одного стартового символа,
поэтому предположение выполняется.
Рассмотрим, что произойдет со строкой при применении
двух возможных правил регулярной грамматики.
При применении правила `<нетерминал> ::= <терминал> <нетерминал>`,
нетерминал в конце строки заменяется на новый нетерминал
и перед ним добавляется один терминал.
При применении правила `<нетерминал> ::= <терминал>`
нетерминал в конце строки заменяется на терминал, и вывод заканчивается.
Т.о. все правила порождают только строки с нетерминалом в конце.
Возьмем в качестве состояний автомата множество нетерминальных символов.
Частично выведенная строка будет соответствовать состоянию автомата для
нетерминала в конце строки.
Тогда правила вида `<A> ::= a <B>` соответствует переходу из
состояния `<A>` в состояние `<B>` с добавлением к слову символа `a`.
Очевидно, что стартовым состоянием автомата будет состояние для стартового символа в грамматике.
Правила вида `<A> ::= a` соответствуют переходу в остановочное состояние
с дописыванием к слову буквы `a`.
Это остановочное состояния не соответствует ни одному нетерминалу,
а является новым состоянием, причем только это состояние является остановочным.

В качестве примера рассмотрим грамматику:

```
<N> ::= 0 | 0 <N>
```

Ей соответствует автомат, имеющий два состояния `<N>`,
соответствующее нетерминалу, и новое состояние `<T>`.
Только состояние `<T>`будет остановочным.
Два правила грамматики соответствуют двум возможным переходам автомата:
правило `<N> ::= 0` соответствует переходу из `<N>` в `<T>`
с добавлением к слову буквы `0`,
а правило `<N> ::= 0 <N>` соответствует переходу из `<N>` в себя
с добавлением буквы `0`.

Легко видеть, что по данному конечному автомату без эпсилон переходов
можно построить соответствующую ему регулярную грамматику.
Таким образом мы заключаем, что между регулярными грамматиками
и конечными автоматами есть взаимно-однозначное соответствие.

Пусть нам дан конечный автомат, проверим, можно ли с его помощью породить
данное слово.
Возьмем автомат из предыдущего примера и попробуем разобрать с его помощью
слово `00`.
Будем обозначать переход из `<A>` в `<B>` по символу `a` следующим образом:
`<A> (a) -> <B>`.
Тогда выходя из стартового состояния и делаю переходы по буквам слова `00`,
получаем следующую цепочку переходов:

```
<N> (0) -> <N> (0) -> <T>
```

т.е. слово `00` порождается автоматом.
Заметим, что из состояния `<N>` есть два перехода по символу `0`,
один в состояние `<N>`, другой в `<T>`.
Автомат, в котором из одного состояния есть несколько переходов по одному
символу, называют *недетерминированным*.
Наоборот, если каждый символ однозначно задает переход для всех состояний,
то автомат называют *детерминированным*.
Так как автомат из примера был недетерминированным, то у нас не было возможности
сразу определить, что первый переход должен быть осуществлен в состояние `<N>`.
Чтобы на практике проверить возможность вывода слова недетерминированным автоматом,
мы должны отслеживать все состояния, которые можно достичь переходами по данным буквам.
Например, в нашем примере достижимы следующие состояния:

```
<N> (0) -> <N> <T> (0) -> <T>
```

Программная реализация детерминированного конечного автомата требует
только одного обращения к таблице переходов на каждую прочитанную букву слова,
что можно выразить в нескольких машинных инструкциях.
Отслеживание списка всех достижимых состояний требует значительно больше ресурсов,
поэтому на практике удобно переходить от недетерминированного автомата
к детерминированному, что к счастью можно сделать всегда.
Чтобы *детерминировать* автомат, нужно объявить множеством состояний нового
автомата все множества состояний исходного автомата,
например, для нашего автомата таких состояний три: `{<N>}`, `{<N>, <T>}`, `{<T>}`.
Если между двумя состояниями исходно автомата возможен переход `<A> (a) -> <B>`,
то в новом автомате разрешены переходы `S (a) -> D`, где
множество состояний `S` содержит `<A>`, а множество `D` содержит `<B>`.
Более того, множество `D` содержит только состояния, в которые можно
попасть переходом по символу `a` из одного из состояний из множества `S`,
Например, в исходном автомате из `<N>` есть два перехода по `0` в `<N>` и в `<T>`,
следовательно в новом автомате из состояния `{<N>}` переход
осуществляется в состояние `{<N>, <T>}`.
Из этого состояния можно попасть в `<N>` по `0`, так как в исходном автомате
был переход `<N> (0) -> <N>`, но также можно попасть в `<T>` по переходу
`<N> (0) -> <T>`.
Мы также должны учесть все переходы из `<T>`, однако таковых в нашем случае нет.
Таким образом переход из состояния `{<N>, <T>}` по символу `0` переходит
в себя.
Состояние `{<T>}` оказалось недостижимо.
Из `{<T>}`  также нет ни одного перехода, так как их не было из `<T>`
в недетерминированном автомате.
Состояния `{<N>, <T>}` и `{<T>}` остановочные, так как содержат
остановочное состояние `<T>`.
Окончательно мы получили следующий детерминированный автомат:

```
{<N>} (0) -> {<N>, <T>}
{<N>, <T>} (0) -> {<N>, <T>}
```

Перейдем к изучению того, как построить конечный автомат для регулярного выражения.
Регулярное выражение определено рекуррентно, поэтому будем последовательно
определять, как строить сложные регулярные выражения из составных частей.

1. Простейшее регулярное выражение состоит из одного литерала `a`.
Соответствующий конечный автомат имеет стартовое состояние `<0>` и
одно остановочное состояние `<1>`, и один переход между ними:
`<0> (a) -> <1>`.

1. Рассмотрим конкатенацию двух регулярных выражений, которым соответствуют
два автомата. Автомат для конкатенации получается добавлением эпсилон
переходов из всех терминальных состояний первого автомата в стартовое
состояние второго, и заменой всех остановочных состояний первого автомата
на неостановочные.

1. Автомат для двух регулярных выражений соединенных оператора объединения `|`
из автоматов для этих выражений получается введением нового стартового состояния
и добавлением к существующим переходам эпсилон переходов
из стартового состояния в стартовые состояния исходных автоматов.

1. Чтобы получить автомат для оператора опции `?`,
достаточно добавить в автомат для регулярного выражения,
к которому применяется оператор, эпсилон переход из стартового состояния
в новое остановочное состояние, из которого больше нет переходов.

1. Чтобы получить автомат для оператора повтора `+`,
достаточно добавить в автомат для регулярного выражения,
к которому применяется оператор, эпсилон переходы
из каждого остановочного состояния в стартовое.

1. Чтобы получить автомат для оператора повтора `*`,
нужно сделать то же преобразование, что и для `+`,
но дополнительно нужно добавить эпсилон переход
из стартового состояния в новое терминальное,
как для оператора `?`.

Вернемся наконец к лексеру.
Лексер должен выделить в потоке символов префикс,
удовлетворяющий одному из регулярных выражений,
и вернуть соответствующее регулярное выражение и префикс.
Т.е. лексер пытается одновременно удовлетворить не по одному,
а нескольким регулярным выражениям.
Если бы мы хотели узнать, удовлетворяет ли префикс хотя бы одному
регулярному выражению, то можно было бы проверять объединение
этих регулярных выражений оператором `|`.
Наша же цель не просто проверить, сработало ли какое-то регулярное выражение,
а найти, какое именно сработало.
Чтобы достигнуть этой цели мы должны остановочные состояния каждого регулярного
выражения пометить, как принадлежащее этому выражению,
после чего строить объединение.
По маркировке остановочного состояния мы можем понять,
какую из лексем удалось выделить.

## Задания

1. Эпсилон переходы в конечном автомате нельзя непосредственно записать
в виде правила регулярной грамматики, так как правила вида
`<A> ::= <B>` не входят в канонический вид правил регулярной грамматики.
Однако конечному автомату с эпсилон правилами все же можно
сопоставить эквивалентную грамматику.
Укажите, как это можно сделать?

1. Можно ли составить регулярное выражение для [правильных скобочных последовательностей](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BA%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)?

1. При достижении остановочного состояния автомат может прекратить
работу, однако может и продолжить, если в нем есть переходы
по следующей букве.
Какой из вариантов предпочтительнее?

1. Регулярные выражения в духе PERL дают больше возможностей,
чем мы допустили выше.
Они позволяют указывать начало и конец строки,
задавать символьные классы, указывать число повторов.
Побробуйте добавить эти возможности в рассмотренную выше схему.

1. Реализуйте конечный автомат.

1. Напишите компилятор регулярных выражений.

1. Напишите генератор лексеров.

-------

[Устройство компилятора <](phases.md)
[Содержание](content.md)
[> Синтаксический анализатор](parser.md)
